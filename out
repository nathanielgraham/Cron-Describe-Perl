[DZ] reading configuration using Dist::Zilla::MVP::Reader::Finder
[@Basic/GatherDir] online, Dist::Zilla::Plugin::GatherDir v6.033
[@Basic/PruneCruft] online, Dist::Zilla::Plugin::PruneCruft v6.033
[@Basic/ManifestSkip] online, Dist::Zilla::Plugin::ManifestSkip v6.033
[@Basic/MetaYAML] online, Dist::Zilla::Plugin::MetaYAML v6.033
[@Basic/License] online, Dist::Zilla::Plugin::License v6.033
[@Basic/Readme] online, Dist::Zilla::Plugin::Readme v6.033
[@Basic/ExtraTests] online, Dist::Zilla::Plugin::ExtraTests v6.033
[@Basic/ExecDir] online, Dist::Zilla::Plugin::ExecDir v6.033
[@Basic/ShareDir] online, Dist::Zilla::Plugin::ShareDir v6.033
[@Basic/MakeMaker] online, Dist::Zilla::Plugin::MakeMaker v6.033
[@Basic/Manifest] online, Dist::Zilla::Plugin::Manifest v6.033
[@Basic/TestRelease] online, Dist::Zilla::Plugin::TestRelease v6.033
[@Basic/ConfirmRelease] online, Dist::Zilla::Plugin::ConfirmRelease v6.033
[@Basic/UploadToCPAN] online, Dist::Zilla::Plugin::UploadToCPAN v6.033
[TestRelease] online, Dist::Zilla::Plugin::TestRelease v6.033
[Prereqs] online, Dist::Zilla::Plugin::Prereqs v6.033
[TestRequires] online, Dist::Zilla::Plugin::Prereqs v6.033
[MetaResources] online, Dist::Zilla::Plugin::MetaResources v6.033
[DZ] building distribution under .build/jONKRp0O2u for installation
[DZ] beginning to build Cron-Describe
[@Basic/GatherDir] considering .
[@Basic/GatherDir] considering out
[@Basic/GatherDir] considering README.md
[@Basic/GatherDir] considering perltidy.ERR
[@Basic/GatherDir] considering dist.ini
[@Basic/GatherDir] considering .gitignore
[@Basic/GatherDir] considering Changes
[@Basic/GatherDir] considering .build
[@Basic/GatherDir] considering t
[@Basic/GatherDir] considering validate.t
[@Basic/GatherDir] considering cron-describe.t
[@Basic/GatherDir] considering validate_quartz.t
[@Basic/GatherDir] considering .git
[@Basic/GatherDir] considering lib
[@Basic/GatherDir] considering Cron
[@Basic/GatherDir] considering Describe.pm
[@Basic/GatherDir] considering Describe
[@Basic/GatherDir] considering Base.pm
[@Basic/GatherDir] considering DayOfMonth.pm
[@Basic/GatherDir] considering Standard.pm
[@Basic/GatherDir] considering Field.pm
[@Basic/GatherDir] considering Quartz.pm
[@Basic/GatherDir] considering DayOfWeek.pm
[@Basic/GatherDir] adding file out
[@Basic/GatherDir] adding file README.md
[@Basic/GatherDir] adding file perltidy.ERR
[@Basic/GatherDir] adding file dist.ini
[@Basic/GatherDir] adding file Changes
[@Basic/GatherDir] adding file t/validate.t
[@Basic/GatherDir] adding file t/cron-describe.t
[@Basic/GatherDir] adding file t/validate_quartz.t
[@Basic/GatherDir] adding file lib/Cron/Describe.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/Base.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/DayOfMonth.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/Standard.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/Field.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/Quartz.pm
[@Basic/GatherDir] adding file lib/Cron/Describe/DayOfWeek.pm
[@Basic/MetaYAML] adding file META.yml
[@Basic/License] adding file LICENSE
[@Basic/Readme] adding file README
[@Basic/MakeMaker] adding file Makefile.PL
[@Basic/Manifest] adding file MANIFEST
[@Basic/ManifestSkip] file MANIFEST.SKIP not found
[DZ] guessing dist's main_module is lib/Cron/Describe.pm
[DZ] dist's main_module is lib/Cron/Describe.pm
[DZ] extracting distribution abstract from lib/Cron/Describe.pm
[@Basic/ExtraTests] MANIFEST has 'bytes' encoding, skipping...
[@Basic/MakeMaker] updating contents of Makefile.PL in memory
[DZ] writing Cron-Describe in .build/jONKRp0O2u
[@Basic/MakeMaker::Runner] running /usr/bin/perl Makefile.PL
Checking if your kit is complete...
Looks good
Generating a Unix-style Makefile
Writing Makefile for Cron::Describe
Writing MYMETA.yml and MYMETA.json
[@Basic/MakeMaker::Runner] running make
cp lib/Cron/Describe/DayOfMonth.pm blib/lib/Cron/Describe/DayOfMonth.pm
cp lib/Cron/Describe.pm blib/lib/Cron/Describe.pm
cp lib/Cron/Describe/Base.pm blib/lib/Cron/Describe/Base.pm
cp lib/Cron/Describe/Field.pm blib/lib/Cron/Describe/Field.pm
cp lib/Cron/Describe/Quartz.pm blib/lib/Cron/Describe/Quartz.pm
cp lib/Cron/Describe/DayOfWeek.pm blib/lib/Cron/Describe/DayOfWeek.pm
cp lib/Cron/Describe/Standard.pm blib/lib/Cron/Describe/Standard.pm
[@Basic/MakeMaker::Runner] running make test TEST_VERBOSE=1
PERL_DL_NONLAZY=1 "/usr/bin/perl" "-MExtUtils::Command::MM" "-MTest::Harness" "-e" "undef *Test::Harness::Switches; test_harness(1, 'blib/lib', 'blib/arch')" t/*.t
syntax error at t/cron-describe.t line 21, near "second Glenn"
Execution of t/cron-describe.t aborted due to compilation errors.
t/cron-describe.t .... 
Dubious, test returned 255 (wstat 65280, 0xff00)
No subtests run 
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='* * * * *', time_zone='UTC'
DEBUG: Normalized expression: '* * * * *'
DEBUG: Split into 5 fields: [*, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 1 * *', time_zone='UTC'
DEBUG: Normalized expression: '0 0 1 * *'
DEBUG: Split into 5 fields: [0, 0, 1, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '1'
DEBUG: Parsing field dom with value '1'
DEBUG: Parsing single part '1' for dom
DEBUG: Matched single pattern 1 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=1, min_value=1, max_value=1, step=1}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='1-5,10-15/2 * * * *', time_zone='UTC'
DEBUG: Normalized expression: '1-5,10-15/2 * * * *'
DEBUG: Split into 5 fields: [1-5,10-15/2, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '1-5,10-15/2'
DEBUG: Parsing field minute with value '1-5,10-15/2'
DEBUG: Parsing list for minute: [1-5, 10-15/2]
DEBUG: Parsing single part '1-5' for minute
DEBUG: Matched range pattern 1-5 for minute
DEBUG: Parsing single part '10-15/2' for minute
DEBUG: Matched range pattern 10-15/2 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=list, sub_patterns=[{type=range, min_value=1, max_value=5, step=1}, {type=range, min_value=10, max_value=15, step=2}]}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='60 * * * *', time_zone='UTC'
DEBUG: Normalized expression: '60 * * * *'
DEBUG: Split into 5 fields: [60, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '60'
DEBUG: Parsing field minute with value '60'
DEBUG: Parsing single part '60' for minute
DEBUG: Matched single pattern 60 for minute
DEBUG: Error: Out of bounds 60 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=error, value=60, min_value=60, max_value=60, step=1}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 60 for minute
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 60 for minute
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='* * 31 2 *', time_zone='UTC'
DEBUG: Normalized expression: '* * 31 2 *'
DEBUG: Split into 5 fields: [*, *, 31, 2, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '31'
DEBUG: Parsing field dom with value '31'
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=31, min_value=31, max_value=31, step=1}
DEBUG: Parsing field 3: month with value '2'
DEBUG: Parsing field month with value '2'
DEBUG: Mapping name '2' for month
DEBUG: Month name '2' mapped to undef
DEBUG: Parsing single part '2' for month
DEBUG: Matched single pattern 2 for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=single, value=2, min_value=2, max_value=2, step=1}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
Use of uninitialized value $b in numeric gt (>) at /home/broom/Cron-Describe-Perl/.build/jONKRp0O2u/blib/lib/Cron/Describe.pm line 11.
DEBUG: Invalid DOM for months [2]: max DOM 31 exceeds 28 days
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid DOM for months [2]: max DOM 31 exceeds 28 days
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 * * SUN', time_zone='UTC'
DEBUG: Normalized expression: '0 0 * * SUN'
DEBUG: Split into 5 fields: [0, 0, *, *, SUN]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value 'SUN'
DEBUG: Parsing field dow with value 'SUN'
DEBUG: Mapping name 'SUN' for dow
DEBUG: DOW name 'SUN' mapped to 0
DEBUG: Mapped name SUN to 0 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='*/15 * * * *', time_zone='UTC'
DEBUG: Normalized expression: '*/15 * * * *'
DEBUG: Split into 5 fields: [*/15, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*/15'
DEBUG: Parsing field minute with value '*/15'
DEBUG: Parsing single part '*/15' for minute
DEBUG: Matched step pattern */15 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=step, min_value=0, max_value=59, start_value=0, step=15}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='1,3,5 * * JAN,FEB *', time_zone='UTC'
DEBUG: Normalized expression: '1,3,5 * * JAN,FEB *'
DEBUG: Split into 5 fields: [1,3,5, *, *, JAN,FEB, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '1,3,5'
DEBUG: Parsing field minute with value '1,3,5'
DEBUG: Parsing list for minute: [1, 3, 5]
DEBUG: Parsing single part '1' for minute
DEBUG: Matched single pattern 1 for minute
DEBUG: Parsing single part '3' for minute
DEBUG: Matched single pattern 3 for minute
DEBUG: Parsing single part '5' for minute
DEBUG: Matched single pattern 5 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=list, sub_patterns=[{type=single, value=1, min_value=1, max_value=1, step=1}, {type=single, value=3, min_value=3, max_value=3, step=1}, {type=single, value=5, min_value=5, max_value=5, step=1}]}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value 'JAN,FEB'
DEBUG: Parsing field month with value 'JAN,FEB'
DEBUG: Parsing name list for month: [JAN, FEB]
DEBUG: Mapping name 'JAN' for month
DEBUG: Month name 'JAN' mapped to 1
DEBUG: Mapping name 'FEB' for month
DEBUG: Month name 'FEB' mapped to 2
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=list, sub_patterns=[{type=single, value=1, min_value=1, max_value=1, step=1}, {type=single, value=2, min_value=2, max_value=2, step=1}]}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 * * * *', time_zone='UTC'
DEBUG: Normalized expression: '0 * * * *'
DEBUG: Split into 5 fields: [0, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 * * 1-5', time_zone='UTC'
DEBUG: Normalized expression: '0 0 * * 1-5'
DEBUG: Split into 5 fields: [0, 0, *, *, 1-5]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '1-5'
DEBUG: Parsing field dow with value '1-5'
DEBUG: Mapping name '1-5' for dow
DEBUG: DOW name '1-5' mapped to undef
DEBUG: Parsing single part '1-5' for dow
DEBUG: Matched range pattern 1-5 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=range, min_value=1, max_value=5, step=1}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 -1 * * *', time_zone='UTC'
DEBUG: Normalized expression: '0 -1 * * *'
DEBUG: Split into 5 fields: [0, -1, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '-1'
DEBUG: Parsing field hour with value '-1'
DEBUG: Parsing single part '-1' for hour
DEBUG: Matched single pattern -1 for hour
DEBUG: Error: Out of bounds -1 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=error, value=-1, min_value=-1, max_value=-1, step=1}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: -1 for hour
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: -1 for hour
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 1-10/3 * *', time_zone='UTC'
DEBUG: Normalized expression: '0 0 1-10/3 * *'
DEBUG: Split into 5 fields: [0, 0, 1-10/3, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '1-10/3'
DEBUG: Parsing field dom with value '1-10/3'
DEBUG: Parsing single part '1-10/3' for dom
DEBUG: Matched range pattern 1-10/3 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=range, min_value=1, max_value=10, step=3}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='* * 31 * *', time_zone='UTC'
DEBUG: Normalized expression: '* * 31 * *'
DEBUG: Split into 5 fields: [*, *, 31, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '31'
DEBUG: Parsing field dom with value '31'
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=31, min_value=31, max_value=31, step=1}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='* * 1,3,31 * *', time_zone='UTC'
DEBUG: Normalized expression: '* * 1,3,31 * *'
DEBUG: Split into 5 fields: [*, *, 1,3,31, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '1,3,31'
DEBUG: Parsing field dom with value '1,3,31'
DEBUG: Parsing list for dom: [1, 3, 31]
DEBUG: Parsing single part '1' for dom
DEBUG: Matched single pattern 1 for dom
DEBUG: Parsing single part '3' for dom
DEBUG: Matched single pattern 3 for dom
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=list, sub_patterns=[{type=single, value=1, min_value=1, max_value=1, step=1}, {type=single, value=3, min_value=3, max_value=3, step=1}, {type=single, value=31, min_value=31, max_value=31, step=1}]}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='* * 32 * *', time_zone='UTC'
DEBUG: Normalized expression: '* * 32 * *'
DEBUG: Split into 5 fields: [*, *, 32, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '32'
DEBUG: Parsing field dom with value '32'
DEBUG: Parsing single part '32' for dom
DEBUG: Matched single pattern 32 for dom
DEBUG: Error: Out of bounds 32 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=error, value=32, min_value=32, max_value=32, step=1}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 32 for dom
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 32 for dom
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 0/0 * *', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0/0 * *'
DEBUG: Split into 5 fields: [0, 0, 0/0, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '0/0'
DEBUG: Parsing field dom with value '0/0'
DEBUG: Parsing single part '0/0' for dom
DEBUG: Matched step pattern 0/0 for dom
DEBUG: Bounds check failed: start_value=0, step=0 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=error}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 0/0 for dom
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 0/0 for dom
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 1-31 * *', time_zone='UTC'
DEBUG: Normalized expression: '0 0 1-31 * *'
DEBUG: Split into 5 fields: [0, 0, 1-31, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: dom with value '1-31'
DEBUG: Parsing field dom with value '1-31'
DEBUG: Parsing single part '1-31' for dom
DEBUG: Matched range pattern 1-31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=range, min_value=1, max_value=31, step=1}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='ABC * * * *', time_zone='UTC'
DEBUG: Normalized expression: 'ABC * * * *'
DEBUG: Split into 5 fields: [ABC, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 5
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: minute with value 'ABC'
DEBUG: Parsing field minute with value 'ABC'
DEBUG: Parsing single part 'ABC' for minute
DEBUG: Error: Invalid format ABC for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=error}
DEBUG: Parsing field 1: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 2: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 3: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 4: dow with value '*'
DEBUG: Parsing field dow with value '*'
DEBUG: Mapping name '*' for dow
DEBUG: DOW name '*' mapped to undef
DEBUG: Parsing single part '*' for dow
DEBUG: Matched pattern * for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=wildcard}
DEBUG: Finished parsing loop, fields count: 5
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: ABC for minute
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: ABC for minute
DEBUG: Standard.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Standard', expression='0 0 * * * * *', time_zone='UTC'
DEBUG: Normalized expression: '0 0 * * * * *'
DEBUG: Split into 7 fields: [0, 0, *, *, *, *, *]
DEBUG: Expression type set to: standard (based on class 'Cron::Describe::Standard'), expected field types: [minute, hour, dom, month, dow]
DEBUG: Checking field count, expected: 5, got: 7
DEBUG: Invalid field count detected, setting is_valid=0 and returning
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid field count for standard: got 7, expected 5 (or 7 for quartz)
t/validate.t ......... 
ok 1 - use Cron::Describe::Standard;
# Subtest: Every minute
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 2 - Every minute
# Subtest: Midnight on 1st
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 3 - Midnight on 1st
# Subtest: Complex minute pattern
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 4 - Complex minute pattern
# Subtest: Invalid minute
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 5 - Invalid minute
# Subtest: 31st of February
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 6 - 31st of February
# Subtest: Every Sunday midnight
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 7 - Every Sunday midnight
# Subtest: Every 15 minutes
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 8 - Every 15 minutes
# Subtest: Specific minutes in Jan/Feb
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 9 - Specific minutes in Jan/Feb
# Subtest: Every hour on the hour
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 10 - Every hour on the hour
# Subtest: Weekdays midnight
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 11 - Weekdays midnight
# Subtest: Negative value in hour
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 12 - Negative value in hour
# Subtest: Step with range in DOM
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 13 - Step with range in DOM
# Subtest: DOM 31 with wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 14 - DOM 31 with wildcard month (valid for some months)
# Subtest: DOM list with 31 and wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 15 - DOM list with 31 and wildcard month (valid for some months)
# Subtest: DOM 32 with wildcard month (invalid for all months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 16 - DOM 32 with wildcard month (invalid for all months)
# Subtest: Invalid step 0 in DOM
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 17 - Invalid step 0 in DOM
# Subtest: DOM range 1-31 with wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 18 - DOM range 1-31 with wildcard month (valid for some months)
# Subtest: Non-numeric minute
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 19 - Non-numeric minute
# Subtest: Too many fields
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 20 - Too many fields
1..20
ok
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * ?'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 L * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 L * ?'
DEBUG: Split into 6 fields: [0, 0, 0, L, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value 'L'
DEBUG: Parsing field dom with value 'L'
DEBUG: Matched pattern L(-0) for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=last, offset=0}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 15W * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 15W * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 15W, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '15W'
DEBUG: Parsing field dom with value '15W'
DEBUG: Matched pattern 15W for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=nearest_weekday, day=15}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * 1#5', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * 1#5'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, 1#5]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '1#5'
DEBUG: Parsing field dow with value '1#5'
DEBUG: Matched pattern 1#5 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=nth, day=1, nth=5}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * 1#6', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * 1#6'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, 1#6]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '1#6'
DEBUG: Parsing field dow with value '1#6'
DEBUG: Matched pattern 1#6 for dow
DEBUG: Error: Invalid nth 6 or day dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=error}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid nth 6 or day 1 for dow
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid nth 6 or day 1 for dow
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 60 0 * * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 60 0 * * ?'
DEBUG: Split into 6 fields: [0, 60, 0, *, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '60'
DEBUG: Parsing field minute with value '60'
DEBUG: Parsing single part '60' for minute
DEBUG: Matched single pattern 60 for minute
DEBUG: Error: Out of bounds 60 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=error, value=60, min_value=60, max_value=60, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 60 for minute
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 60 for minute
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 31 2 ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 31 2 ?'
DEBUG: Split into 6 fields: [0, 0, 0, 31, 2, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '31'
DEBUG: Parsing field dom with value '31'
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=31, min_value=31, max_value=31, step=1}
DEBUG: Parsing field 4: month with value '2'
DEBUG: Parsing field month with value '2'
DEBUG: Mapping name '2' for month
DEBUG: Month name '2' mapped to undef
DEBUG: Parsing single part '2' for month
DEBUG: Matched single pattern 2 for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=single, value=2, min_value=2, max_value=2, step=1}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
Use of uninitialized value $b in numeric gt (>) at /home/broom/Cron-Describe-Perl/.build/jONKRp0O2u/blib/lib/Cron/Describe.pm line 11.
DEBUG: Invalid DOM for months [2]: max DOM 31 exceeds 28 days
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid DOM for months [2]: max DOM 31 exceeds 28 days
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * 1L', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * 1L'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, 1L]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '1L'
DEBUG: Parsing field dow with value '1L'
DEBUG: Matched pattern 1L for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=last_of_day, day=1}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * ? 2025', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * ? 2025'
DEBUG: Split into 7 fields: [0, 0, 0, *, *, ?, 2025]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 7
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Parsing field 6: year with value '2025'
DEBUG: Parsing field year with value '2025'
DEBUG: Parsing single part '2025' for year
DEBUG: Matched single pattern 2025 for year
DEBUG: Field.pm loaded (mtime: 1759370259) for type year
DEBUG: Parsed field year: {type=single, value=2025, min_value=2025, max_value=2025, step=1}
DEBUG: Finished parsing loop, fields count: 7
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 1-5,10-15/2 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 1-5,10-15/2 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 1-5,10-15/2, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '1-5,10-15/2'
DEBUG: Parsing field dom with value '1-5,10-15/2'
DEBUG: Parsing list for dom: [1-5, 10-15/2]
DEBUG: Parsing single part '1-5' for dom
DEBUG: Matched range pattern 1-5 for dom
DEBUG: Parsing single part '10-15/2' for dom
DEBUG: Matched range pattern 10-15/2 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=list, sub_patterns=[{type=range, min_value=1, max_value=5, step=1}, {type=range, min_value=10, max_value=15, step=2}]}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 LW * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 LW * ?'
DEBUG: Split into 6 fields: [0, 0, 0, LW, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value 'LW'
DEBUG: Parsing field dom with value 'LW'
DEBUG: Matched pattern LW for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=last_weekday, offset=0}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='5/10 * * * * ?', time_zone='UTC'
DEBUG: Normalized expression: '5/10 * * * * ?'
DEBUG: Split into 6 fields: [5/10, *, *, *, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '5/10'
DEBUG: Parsing field seconds with value '5/10'
DEBUG: Parsing single part '5/10' for seconds
DEBUG: Matched step pattern 5/10 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=step, min_value=5, max_value=59, start_value=5, step=10}
DEBUG: Parsing field 1: minute with value '*'
DEBUG: Parsing field minute with value '*'
DEBUG: Parsing single part '*' for minute
DEBUG: Matched pattern * for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=wildcard}
DEBUG: Parsing field 2: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 5/15 * * * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 5/15 * * * ?'
DEBUG: Split into 6 fields: [0, 5/15, *, *, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '5/15'
DEBUG: Parsing field minute with value '5/15'
DEBUG: Parsing single part '5/15' for minute
DEBUG: Matched step pattern 5/15 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=step, min_value=5, max_value=59, start_value=5, step=15}
DEBUG: Parsing field 2: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * 2#3', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * 2#3'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, 2#3]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '2#3'
DEBUG: Parsing field dow with value '2#3'
DEBUG: Matched pattern 2#3 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=nth, day=2, nth=3}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 ? * MON,WED,FRI', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 ? * MON,WED,FRI'
DEBUG: Split into 6 fields: [0, 0, 0, ?, *, MON,WED,FRI]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '?'
DEBUG: Parsing field dom with value '?'
DEBUG: Parsing single part '?' for dom
DEBUG: Matched pattern ? for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=unspecified}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value 'MON,WED,FRI'
DEBUG: Parsing field dow with value 'MON,WED,FRI'
DEBUG: Parsing name list for dow: [MON, WED, FRI]
DEBUG: Mapping name 'MON' for dow
DEBUG: DOW name 'MON' mapped to 1
DEBUG: Mapping name 'WED' for dow
DEBUG: DOW name 'WED' mapped to 3
DEBUG: Mapping name 'FRI' for dow
DEBUG: DOW name 'FRI' mapped to 5
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=list, sub_patterns=[{type=single, value=1, min_value=1, max_value=1, step=1}, {type=single, value=3, min_value=3, max_value=3, step=1}, {type=single, value=5, min_value=5, max_value=5, step=1}]}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 LW * MON', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 LW * MON'
DEBUG: Split into 6 fields: [0, 0, 0, LW, *, MON]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value 'LW'
DEBUG: Parsing field dom with value 'LW'
DEBUG: Matched pattern LW for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=last_weekday, offset=0}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value 'MON'
DEBUG: Parsing field dow with value 'MON'
DEBUG: Mapping name 'MON' for dow
DEBUG: DOW name 'MON' mapped to 1
DEBUG: Mapped name MON to 1 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=single, value=1, min_value=1, max_value=1, step=1}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Invalid Quartz DOM-DOW conflict
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Quartz DOM-DOW conflict: both non-trivial
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * ?W', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * ?W'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, ?W]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?W'
DEBUG: Parsing field dow with value '?W'
DEBUG: Mapping name '?W' for dow
DEBUG: DOW name '?W' mapped to undef
DEBUG: Parsing single part '?W' for dow
DEBUG: Error: Invalid format ?W for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=error}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: ?W for dow
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: ?W for dow
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='*/5 0 * * * ?', time_zone='UTC'
DEBUG: Normalized expression: '*/5 0 * * * ?'
DEBUG: Split into 6 fields: [*/5, 0, *, *, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '*/5'
DEBUG: Parsing field seconds with value '*/5'
DEBUG: Parsing single part '*/5' for seconds
DEBUG: Matched step pattern */5 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=step, min_value=0, max_value=59, start_value=0, step=5}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '*'
DEBUG: Parsing field hour with value '*'
DEBUG: Parsing single part '*' for hour
DEBUG: Matched pattern * for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=wildcard}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 L-5 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 L-5 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, L-5, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value 'L-5'
DEBUG: Parsing field dom with value 'L-5'
DEBUG: Matched pattern L(-5) for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=last, offset=5}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 32W * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 32W * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 32W, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '32W'
DEBUG: Parsing field dom with value '32W'
DEBUG: Matched pattern 32W for dom
DEBUG: Error: Invalid day 32 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=error}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid day 32 for dom
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid day 32 for dom
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * 8#3', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * 8#3'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, 8#3]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '8#3'
DEBUG: Parsing field dow with value '8#3'
DEBUG: Matched pattern 8#3 for dow
DEBUG: Error: Invalid nth 3 or day dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=error}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid nth 3 or day 8 for dow
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid nth 3 or day 8 for dow
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * W#3', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * W#3'
DEBUG: Split into 6 fields: [0, 0, 0, *, *, W#3]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value 'W#3'
DEBUG: Parsing field dow with value 'W#3'
DEBUG: Mapping name 'W#3' for dow
DEBUG: DOW name 'W#3' mapped to undef
DEBUG: Parsing single part 'W#3' for dow
DEBUG: Error: Invalid format W#3 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=error}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: W#3 for dow
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Invalid format: W#3 for dow
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 15 * MON', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 15 * MON'
DEBUG: Split into 6 fields: [0, 0, 0, 15, *, MON]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '15'
DEBUG: Parsing field dom with value '15'
DEBUG: Parsing single part '15' for dom
DEBUG: Matched single pattern 15 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=15, min_value=15, max_value=15, step=1}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value 'MON'
DEBUG: Parsing field dow with value 'MON'
DEBUG: Mapping name 'MON' for dow
DEBUG: DOW name 'MON' mapped to 1
DEBUG: Mapped name MON to 1 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=single, value=1, min_value=1, max_value=1, step=1}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Invalid Quartz DOM-DOW conflict
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Quartz DOM-DOW conflict: both non-trivial
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 ? * 1#5', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 ? * 1#5'
DEBUG: Split into 6 fields: [0, 0, 0, ?, *, 1#5]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '?'
DEBUG: Parsing field dom with value '?'
DEBUG: Parsing single part '?' for dom
DEBUG: Matched pattern ? for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=unspecified}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '1#5'
DEBUG: Parsing field dow with value '1#5'
DEBUG: Matched pattern 1#5 for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=nth, day=1, nth=5}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * ? 1969', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * ? 1969'
DEBUG: Split into 7 fields: [0, 0, 0, *, *, ?, 1969]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 7
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Parsing field 6: year with value '1969'
DEBUG: Parsing field year with value '1969'
DEBUG: Parsing single part '1969' for year
DEBUG: Matched single pattern 1969 for year
DEBUG: Error: Out of bounds 1969 for year
DEBUG: Field.pm loaded (mtime: 1759370259) for type year
DEBUG: Parsed field year: {type=error, value=1969, min_value=1969, max_value=1969, step=1}
DEBUG: Finished parsing loop, fields count: 7
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 1969 for year
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 1969 for year
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 * * ? 2025-2030', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 * * ? 2025-2030'
DEBUG: Split into 7 fields: [0, 0, 0, *, *, ?, 2025-2030]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 7
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '*'
DEBUG: Parsing field dom with value '*'
DEBUG: Parsing single part '*' for dom
DEBUG: Matched pattern * for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=wildcard}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Parsing field 6: year with value '2025-2030'
DEBUG: Parsing field year with value '2025-2030'
DEBUG: Parsing single part '2025-2030' for year
DEBUG: Matched range pattern 2025-2030 for year
DEBUG: Field.pm loaded (mtime: 1759370259) for type year
DEBUG: Parsed field year: {type=range, min_value=2025, max_value=2030, step=1}
DEBUG: Finished parsing loop, fields count: 7
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 31 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 31 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 31, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '31'
DEBUG: Parsing field dom with value '31'
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=single, value=31, min_value=31, max_value=31, step=1}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 1,3,31 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 1,3,31 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 1,3,31, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '1,3,31'
DEBUG: Parsing field dom with value '1,3,31'
DEBUG: Parsing list for dom: [1, 3, 31]
DEBUG: Parsing single part '1' for dom
DEBUG: Matched single pattern 1 for dom
DEBUG: Parsing single part '3' for dom
DEBUG: Matched single pattern 3 for dom
DEBUG: Parsing single part '31' for dom
DEBUG: Matched single pattern 31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=list, sub_patterns=[{type=single, value=1, min_value=1, max_value=1, step=1}, {type=single, value=3, min_value=3, max_value=3, step=1}, {type=single, value=31, min_value=31, max_value=31, step=1}]}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 32 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 32 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 32, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '32'
DEBUG: Parsing field dom with value '32'
DEBUG: Parsing single part '32' for dom
DEBUG: Matched single pattern 32 for dom
DEBUG: Error: Out of bounds 32 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=error, value=32, min_value=32, max_value=32, step=1}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 32 for dom
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 32 for dom
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 0/0 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 0/0 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 0/0, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '0/0'
DEBUG: Parsing field dom with value '0/0'
DEBUG: Parsing single part '0/0' for dom
DEBUG: Matched step pattern 0/0 for dom
DEBUG: Bounds check failed: start_value=0, step=0 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=error}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 0/0 for dom
DEBUG: is_valid returned: 0
DEBUG: Validating expression
DEBUG: Validation failed due to parsing errors: Out of bounds: 0/0 for dom
DEBUG: Quartz.pm loaded (mtime: 1759370259)
DEBUG: Describe.pm loaded (mtime: 1759370259)
DEBUG: Initializing with class='Cron::Describe::Quartz', expression='0 0 0 1-31 * ?', time_zone='UTC'
DEBUG: Normalized expression: '0 0 0 1-31 * ?'
DEBUG: Split into 6 fields: [0, 0, 0, 1-31, *, ?]
DEBUG: Expression type set to: quartz (based on class 'Cron::Describe::Quartz'), expected field types: [seconds, minute, hour, dom, month, dow, year]
DEBUG: Checking field count, expected: 6, got: 6
DEBUG: Field count valid, proceeding to parse fields
DEBUG: Parsing field 0: seconds with value '0'
DEBUG: Parsing field seconds with value '0'
DEBUG: Parsing single part '0' for seconds
DEBUG: Matched single pattern 0 for seconds
DEBUG: Field.pm loaded (mtime: 1759370259) for type seconds
DEBUG: Parsed field seconds: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 1: minute with value '0'
DEBUG: Parsing field minute with value '0'
DEBUG: Parsing single part '0' for minute
DEBUG: Matched single pattern 0 for minute
DEBUG: Field.pm loaded (mtime: 1759370259) for type minute
DEBUG: Parsed field minute: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 2: hour with value '0'
DEBUG: Parsing field hour with value '0'
DEBUG: Parsing single part '0' for hour
DEBUG: Matched single pattern 0 for hour
DEBUG: Field.pm loaded (mtime: 1759370259) for type hour
DEBUG: Parsed field hour: {type=single, value=0, min_value=0, max_value=0, step=1}
DEBUG: Parsing field 3: dom with value '1-31'
DEBUG: Parsing field dom with value '1-31'
DEBUG: Parsing single part '1-31' for dom
DEBUG: Matched range pattern 1-31 for dom
DEBUG: Field.pm loaded (mtime: 1759370259) for type dom
DEBUG: DayOfMonth.pm loaded (mtime: 1759370259) for type dom
DEBUG: Parsed field dom: {type=range, min_value=1, max_value=31, step=1}
DEBUG: Parsing field 4: month with value '*'
DEBUG: Parsing field month with value '*'
DEBUG: Mapping name '*' for month
DEBUG: Month name '*' mapped to undef
DEBUG: Parsing single part '*' for month
DEBUG: Matched pattern * for month
DEBUG: Field.pm loaded (mtime: 1759370259) for type month
DEBUG: Parsed field month: {type=wildcard}
DEBUG: Parsing field 5: dow with value '?'
DEBUG: Parsing field dow with value '?'
DEBUG: Mapping name '?' for dow
DEBUG: DOW name '?' mapped to undef
DEBUG: Parsing single part '?' for dow
DEBUG: Matched pattern ? for dow
DEBUG: Field.pm loaded (mtime: 1759370259) for type dow
DEBUG: DayOfWeek.pm loaded (mtime: 1759370259) for type dow
DEBUG: Parsed field dow: {type=unspecified}
DEBUG: Finished parsing loop, fields count: 6
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
DEBUG: is_valid returned: 1
DEBUG: Validating expression
DEBUG: DOM validation passed (wildcard DOM or month)
DEBUG: Skipping year validation (no year field)
DEBUG: Validation passed
t/validate_quartz.t .. 
ok 1 - use Cron::Describe::Quartz;
# Subtest: Every day at midnight
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 2 - Every day at midnight
# Subtest: Last day of month
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 3 - Last day of month
# Subtest: Nearest weekday to 15th
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 4 - Nearest weekday to 15th
# Subtest: 5th Monday
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 5 - 5th Monday
# Subtest: 6th Monday impossible
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 6 - 6th Monday impossible
# Subtest: Invalid minute
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 7 - Invalid minute
# Subtest: 31st of February (valid parse, invalid semantics)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 8 - 31st of February (valid parse, invalid semantics)
# Subtest: Last Monday of month
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 9 - Last Monday of month
# Subtest: Every day in 2025
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 10 - Every day in 2025
# Subtest: Complex DOM pattern
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 11 - Complex DOM pattern
# Subtest: Last weekday of month
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 12 - Last weekday of month
# Subtest: Every 10 seconds starting at 5
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 13 - Every 10 seconds starting at 5
# Subtest: Every 15 minutes starting at 5
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 14 - Every 15 minutes starting at 5
# Subtest: Third Tuesday
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 15 - Third Tuesday
# Subtest: DOW list with names
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 16 - DOW list with names
# Subtest: LW with specific DOW
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 17 - LW with specific DOW
# Subtest: Invalid Quartz token ?W
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 18 - Invalid Quartz token ?W
# Subtest: Every second in first minute
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 19 - Every second in first minute
# Subtest: Last day minus offset
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 20 - Last day minus offset
# Subtest: Invalid nearest weekday
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 21 - Invalid nearest weekday
# Subtest: Invalid nth day
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 22 - Invalid nth day
# Subtest: Malformed Quartz token
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 23 - Malformed Quartz token
# Subtest: Quartz DOM-DOW conflict
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 24 - Quartz DOM-DOW conflict
# Subtest: Valid nth day
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 25 - Valid nth day
# Subtest: Invalid past year
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 26 - Invalid past year
# Subtest: Valid year range
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 27 - Valid year range
# Subtest: DOM 31 with wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 28 - DOM 31 with wildcard month (valid for some months)
# Subtest: DOM list with 31 and wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 29 - DOM list with 31 and wildcard month (valid for some months)
# Subtest: DOM 32 with wildcard month (invalid for all months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 30 - DOM 32 with wildcard month (invalid for all months)
# Subtest: Invalid step 0 in DOM
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 31 - Invalid step 0 in DOM
# Subtest: DOM range 1-31 with wildcard month (valid for some months)
    ok 1 - Parsed fields match expected structure
    ok 2 - is_valid
    1..2
ok 32 - DOM range 1-31 with wildcard month (valid for some months)
1..32
ok

Test Summary Report
-------------------
t/cron-describe.t  (Wstat: 65280 (exited 255) Tests: 0 Failed: 0)
  Non-zero exit status: 255
  Parse errors: No plan found in TAP output
Files=3, Tests=52,  0 wallclock secs ( 0.02 usr  0.01 sys +  0.30 cusr  0.04 csys =  0.37 CPU)
Result: FAIL
Failed 1/3 test programs. 0/52 subtests failed.
make: *** [Makefile:836: test_dynamic] Error 255
error running make test
