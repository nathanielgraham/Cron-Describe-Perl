package Cron::Describe;
use strict;
use warnings;
use Carp qw(croak);
use Time::Moment;
use Cron::Describe::Utils qw(
    %month_map %dow_map
);
use Cron::Describe::Utils qw(fill_template @day_names num_to_ordinal format_list format_time field_unit join_parts);
use Cron::Describe::SinglePattern;
use Cron::Describe::RangePattern;
use Cron::Describe::StepPattern;
use Cron::Describe::WildcardPattern;
use Cron::Describe::UnspecifiedPattern;
use Cron::Describe::DayOfMonthPattern;
use Cron::Describe::DayOfWeekPattern;
use Cron::Describe::ListPattern;

# Pre-compiled regex constants (Describe.pm only)
use constant {
    SINGLE_RE         => qr/^\d+$/,
    RANGE_RE          => qr/^\d+-\d+$/,
    STEP_RE           => qr/^(\*|\d+|\d+-\d+)\/\d+$/,
    LIST_RE           => qr/^[^,]+(,[^,]+)+$/,
    DOM_SPECIAL_RE    => qr/^(L(?:-\d+)?|LW|\d+W)$/,
    DOW_SPECIAL_RE    => qr/^\d+(L|#\d+)$/,
    MONTH_PATTERN_RE  => qr/^(\d+|\d+-\d+|[\d,]+|\*|\d+-\d+\/\d+|\d+\/\d+)$/,
    DOW_PATTERN_RE    => qr/^(\d+L|\d+#\d+|[\d,]+|\*|\?|\d+-\d+)$/,
    MONTH_NAME_RE     => do {
        my $month_re = join '|', map { quotemeta } sort { length($b) <=> length($a) } keys %month_map;
        qr/($month_re)/i;
    },
    DOW_NAME_RE       => do {
        my $dow_re = join '|', map { quotemeta } sort { length($b) <=> length($a) } keys %dow_map;
        qr/($dow_re)/i;
    },
};

sub new_from_quartz {
    my ($class, %args) = @_;
    my $expression = delete $args{expression} // croak "Missing 'expression'";
    my $utc = delete $args{utc} // delete $args{utc_offset} // 0;
    croak "Unknown params: " . join(", ", keys %args) if keys %args;
    
    print STDERR "DEBUG: Describe::new_from_quartz: expression='$expression', utc_offset=$utc\n" if $ENV{Cron_DEBUG};
    my $self = bless {
        expression => $expression,
        utc_offset => $utc,
        patterns => [],
        is_valid => 1,
        error_message => '',
    }, $class;

    my $normalized;
    eval {
        $normalized = $self->normalize_expression($expression);
        print STDERR "DEBUG: Describe::normalize_expression: original='$expression'\n" if $ENV{Cron_DEBUG};
        print STDERR "DEBUG: Describe::normalize_expression: normalized='$normalized'\n" if $ENV{Cron_DEBUG};
    };
    if ($@) {
        print STDERR "DEBUG: Error in normalize_expression: $@\n" if $ENV{Cron_DEBUG};
        $self->{is_valid} = 0;
        $self->{error_message} = $@;
        return $self;
    }

    my @fields = split /\s+/, $normalized;
    croak "Quartz cron must have 6 or 7 fields, got " . scalar(@fields) unless @fields >= 6 && @fields <= 7;

    my @field_types = qw(seconds minute hour dom month dow year);
    my @min_values = (0, 0, 0, 1, 1, 0, 1970);
    my @max_values = (59, 59, 23, 31, 12, 7, 2199);

    if (@fields == 6) {
        push @fields, '*';
    }

    my %pattern_dispatch = (
        qr/^\*$/ => sub { Cron::Describe::WildcardPattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
        qr/^\?$/ => sub { Cron::Describe::UnspecifiedPattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
        SINGLE_RE() => sub { Cron::Describe::SinglePattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
        RANGE_RE() => sub { Cron::Describe::RangePattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
        STEP_RE() => sub { Cron::Describe::StepPattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
        LIST_RE() => sub { Cron::Describe::ListPattern->new($_[0], $min_values[$_[2]], $max_values[$_[2]], $_[1]) },
    );

    for my $i (0..6) {
        my $field = $fields[$i];
        my $field_type = $field_types[$i];
        print STDERR "DEBUG: Describe::new_from_quartz: field='$field', field_type=$field_type, index=$i\n" if $ENV{Cron_DEBUG};
        my $pattern;

        eval {
            my $matched = 0;
            for my $re (keys %pattern_dispatch) {
                if ($field =~ $re) {
                    print STDERR "DEBUG: trying dispatch for '$field' with regex $re\n" if $ENV{Cron_DEBUG};
                    $pattern = $pattern_dispatch{$re}->($field, $field_type, $i);
                    $matched = 1;
                    last;
                }
            }

            if (!$matched) {
                if ($field_type eq 'dom' && $field =~ DOM_SPECIAL_RE) {
                    print STDERR "DEBUG: trying DayOfMonthPattern for '$field'\n" if $ENV{Cron_DEBUG};
                    $pattern = Cron::Describe::DayOfMonthPattern->new($field, $min_values[$i], $max_values[$i], $field_type);
                    $matched = 1;
                } elsif ($field_type eq 'dow' && $field =~ DOW_SPECIAL_RE) {
                    print STDERR "DEBUG: trying DayOfWeekPattern for '$field'\n" if $ENV{Cron_DEBUG};
                    $pattern = Cron::Describe::DayOfWeekPattern->new($field, $min_values[$i], $max_values[$i], $field_type);
                    $matched = 1;
                }
            }

            print STDERR "DEBUG: field='$field', field_type=$field_type, matched=$matched\n" if $ENV{Cron_DEBUG};
            croak "Invalid pattern '$field' for $field_type" unless $matched;

            push @{$self->{patterns}}, $pattern;
        };
        if ($@) {
            print STDERR "DEBUG: Error in field parsing: $@\n" if $ENV{Cron_DEBUG};
            $self->{is_valid} = 0;
            $self->{error_message} = $@;
            return $self;
        }
    }

    $self->_validate_dom_month_combination();

    if ($self->{patterns}[3]->to_string ne '?' && $self->{patterns}[5]->to_string ne '?') {
        $self->{is_valid} = 0;
        $self->{error_message} = "Cannot specify both day-of-month and day-of-week; one must be '?'";
    }

    return $self;
}

sub new_from_unix {
    my ($class, %args) = @_;
    my $expression = delete $args{expression} // croak "Missing 'expression'";
    my $tz = delete $args{tz} // delete $args{time_zone};
    my $utc = delete $args{utc} // delete $args{utc_offset} // 0;
    $utc = $class->_tz_to_utc_offset($tz) if $tz && $utc == 0;
    croak "Unknown params: " . join(", ", keys %args) if keys %args;
    
    my $quartz_expr = $class->_unix_to_quartz($expression);
    return $class->new_from_quartz(
        expression => $quartz_expr, 
        utc => $utc
    );
}

sub new {
    my ($class, %args) = @_;
    my $expression = delete $args{expression} // croak "Missing 'expression'";
    my $tz = delete $args{tz} // delete $args{time_zone};
    my $utc = delete $args{utc} // delete $args{utc_offset} // 0;
    $utc = $class->_tz_to_utc_offset($tz) if $tz && $utc == 0;
    croak "Unknown params: " . join(", ", keys %args) if keys %args;
    
    my @fields = split /\s+/, $expression;
    if (@fields == 5) {
        return $class->new_from_unix(
            expression => $expression, 
            utc => $utc
        );
    } else {
        return $class->new_from_quartz(
            expression => $expression, 
            utc => $utc
        );
    }
}

sub _unix_to_quartz {
    my ($class, $expression) = @_;
    my @fields = split /\s+/, $expression;
    croak "Unix cron must have exactly 5 fields, got " . scalar(@fields) unless @fields == 5;

    my ($min, $hour, $dom, $month, $dow) = @fields;

    # Unix NO special chars (? L W #)
    for my $field ($min, $hour, $dom, $month, $dow) {
        croak "Unix cron cannot contain special characters: '$field'" if $field =~ /[?LW#]/;
    }

    # Unix DOW: 0/7=Sun→1, 1=Mon→2, ..., 6=Sat→7
    $dow =~ s/\b0\b|7/1/g;
    $dow =~ s/\b(\d)\b/$1+1/eeg;

    # Check DOM/DOW conflict (both non-*)
    my $dom_star = $dom eq '*';
    my $dow_star = $dow eq '*';
    croak "Unix cron cannot specify both day-of-month and day-of-week (DOM='$dom', DOW='$dow')"
        unless $dom_star || $dow_star;

    # FIXED LOGIC: PREFER DOM (keep specified, ? other)
    my $quartz_dom = $dom_star ? '*' : $dom;
    my $quartz_dow = $dow_star ? '*' : $dow;

    # Every day: DOM=* DOW=* → DOW=?
    if ($dom_star && $dow_star) {
        $quartz_dow = '?';
    }
    # DOM specified → DOW=?
    elsif (!$dom_star) {
        $quartz_dow = '?';
    }
    # DOW specified → DOM=?
    else {
        $quartz_dom = '?';
    }

    # FULL PADDING: SEC=0, MIN, HOUR, DOM, MONTH, DOW, YEAR=*
    return join ' ', 0, $min, $hour, $quartz_dom, $month, $quartz_dow, '*';
}

sub _tz_to_utc_offset {
    my ($class, $tz) = @_;
    return 0 unless $tz;
    eval {
        require DateTime::TimeZone;
        my $zone = DateTime::TimeZone->new(name => $tz) || croak "Invalid timezone '$tz'";
        my $tm = Time::Moment->now();
        my $offset = $zone->offset_for_datetime($tm) / 60;
        return $offset;
    };
    croak "Invalid timezone '$tz': $@" if $@;
}

sub utc_offset {
    my ($self, $new_offset) = @_;
    if (@_ > 1) {
        if (!defined $new_offset || $new_offset !~ /^-?\d+$/ || $new_offset < -1080 || $new_offset > 1080) {
            croak "Invalid utc_offset '$new_offset': must be an integer between -1080 and 1080 minutes";
        }
        $self->{utc_offset} = $new_offset;
        print STDERR "DEBUG: utc_offset: set to $new_offset\n" if $ENV{Cron_DEBUG};
    }
    print STDERR "DEBUG: utc_offset: returning $self->{utc_offset}\n" if $ENV{Cron_DEBUG};
    return $self->{utc_offset};
}

sub _validate_dom_month_combination {
    my ($self) = @_;
    my $dom = $self->{patterns}[3]->to_string;
    my $month = $self->{patterns}[4]->to_string;
    my $year = $self->{patterns}[6]->to_string;

    my $month_num = $month =~ SINGLE_RE ? int($month) : undef;
    my $year_num = $year =~ SINGLE_RE ? int($year) : undef;

    return unless defined $month_num;

    my $validate_sub_pattern = sub {
        my ($sub_dom, $month_num, $error_prefix) = @_;
        if ($sub_dom =~ SINGLE_RE) {
            my $day = int($sub_dom);
            if ($month_num == 2) {
                my $is_leap = defined $year_num ? Time::Moment->new(year => $year_num)->is_leap_year : 0;
                if ($day > 29 || ($day == 29 && !$is_leap)) {
                    $self->{is_valid} = 0;
                    $self->{error_message} = "$error_prefix $day is invalid for February (month $month_num)";
                    return 0;
                }
            } elsif ($day > 30 && ($month_num == 4 || $month_num == 6 || $month_num == 9 || $month_num == 11)) {
                $self->{is_valid} = 0;
                $self->{error_message} = "$error_prefix $day is invalid for month $month_num";
                return 0;
            }
        } elsif ($sub_dom =~ RANGE_RE) {
            my ($start, $end) = split /-/, $sub_dom;
            if ($month_num == 2) {
                my $is_leap = defined $year_num ? Time::Moment->new(year => $year_num)->is_leap_year : 0;
                if ($end > 29 || ($end == 29 && !$is_leap)) {
                    $self->{is_valid} = 0;
                    $self->{error_message} = "$error_prefix range $start-$end is invalid for February (month $month_num)";
                    return 0;
                }
            } elsif ($end > 30 && ($month_num == 4 || $month_num == 6 || $month_num == 9 || $month_num == 11)) {
                $self->{is_valid} = 0;
                $self->{error_message} = "$error_prefix range $start-$end is invalid for month $month_num";
                return 0;
            }
        } elsif ($sub_dom =~ STEP_RE) {
            my ($range, $step) = $sub_dom =~ STEP_RE;
            if ($month_num == 2) {
                my $is_leap = defined $year_num ? Time::Moment->new(year => $year_num)->is_leap_year : 0;
                if ($range eq '*' || ($range =~ RANGE_RE && $2 > 29) || ($range =~ RANGE_RE && $2 == 29 && !$is_leap)) {
                    $self->{is_valid} = 0;
                    $self->{error_message} = "$error_prefix step pattern $sub_dom is invalid for February (month $month_num)";
                    return 0;
                }
            } elsif (($range eq '*' || ($range =~ RANGE_RE && $2 > 30)) && ($month_num == 4 || $month_num == 6 || $month_num == 9 || $month_num == 11)) {
                $self->{is_valid} = 0;
                $self->{error_message} = "$error_prefix step pattern $sub_dom is invalid for month $month_num";
                return 0;
            }
        }
        return 1;
    };

    if ($dom =~ SINGLE_RE) {
        $validate_sub_pattern->($dom, $month_num, "Day");
    } elsif ($dom =~ RANGE_RE) {
        $validate_sub_pattern->($dom, $month_num, "Day");
    } elsif ($dom =~ STEP_RE) {
        $validate_sub_pattern->($dom, $month_num, "Day");
    } elsif ($dom =~ LIST_RE) {
        my @sub_doms = split /,/, $dom;
        foreach my $sub_dom (@sub_doms) {
            last unless $validate_sub_pattern->($sub_dom, $month_num, "Day");
        }
    }
}

sub normalize_expression {
    my ($self, $expression) = @_;
    croak "Empty cron expression is invalid" unless $expression;

    print STDERR "DEBUG: normalize_expression: before='$expression'\n" if $ENV{Cron_DEBUG};

    $expression =~ s/^\s+|\s+$//g;
    $expression =~ s/\s+/ /g;

    my @fields = split /\s+/, $expression;
    croak "Invalid cron expression: expected 6 or 7 fields, got " . scalar(@fields) unless @fields >= 6 && @fields <= 7;

    if (@fields == 6) {
        push @fields, '*';
    }

    for my $i (0..$#fields) {
        my $field = $fields[$i];
        $field =~ s/\s+//g;

        if ($i == 3) {
            if ($field =~ /,/) {
                croak "Invalid use of 'L' in list for day-of-month" if $field =~ /\bL\b/;
                croak "Invalid use of 'W' in list for day-of-month" if $field =~ /W,/ || $field =~ /,W/;
            }
            if ($field =~ /-/ && $field !~ DOM_SPECIAL_RE) {
                croak "Invalid use of 'L' in range for day-of-month" if $field =~ /\bL\b/;
                croak "Invalid use of 'W' in range for day-of-month" if $field =~ /W-/ || $field =~ /-W/;
            }
            $field = uc($field);
        }

        if ($i == 4) {
            if ($field =~ /^[a-zA-Z]+-[a-zA-Z]+$/) {
                my ($start, $end) = split /-/, $field;
                croak "Invalid month name '$start' in month field" unless $start =~ MONTH_NAME_RE;
                croak "Invalid month name '$end' in month field" unless $end =~ MONTH_NAME_RE;
                my $start_num = $month_map{lc($start)};
                my $end_num = $month_map{lc($end)};
                $field = "$start_num-$end_num";
            } elsif ($field =~ /[a-zA-Z]/) {
                my $original_field = $field;
                my @tokens = split /,/, $field;
                my @normalized_tokens;
                foreach my $token (@tokens) {
                    if ($token =~ /^[a-zA-Z]+$/) {
                        croak "Invalid month name '$token' in month field" unless $token =~ MONTH_NAME_RE;
                        push @normalized_tokens, $month_map{lc($token)};
                    } else {
                        push @normalized_tokens, $token;
                    }
                }
                $field = join ',', @normalized_tokens;
                print STDERR "DEBUG: normalize_expression: MONTH_NAME_RE substitution: '$original_field' -> '$field'\n" if $ENV{Cron_DEBUG};
            }
            croak "Invalid pattern '$field' for month field" unless $field =~ MONTH_PATTERN_RE;
        }

        if ($i == 5) {
            croak "Invalid use of 'W' in day-of-week field" if $field =~ /W/;
            if ($field =~ /[a-zA-Z]/) {
                my $original_field = $field;
                if ($field =~ /^[a-zA-Z]+-[a-zA-Z]+$/) {
                    my ($start, $end) = split /-/, $field;
                    croak "Invalid day name '$start' in day-of-week field" unless $start =~ DOW_NAME_RE;
                    croak "Invalid day name '$end' in day-of-week field" unless $end =~ DOW_NAME_RE;
                    my $start_num = $dow_map{lc($start)};
                    my $end_num = $dow_map{lc($end)};
                    $field = "$start_num-$end_num";
                    print STDERR "DEBUG: normalize_expression: DOW_NAME_RE range substitution: '$original_field' -> '$field'\n" if $ENV{Cron_DEBUG};
                } else {
                    my @tokens = split /,/, $field;
                    my @normalized_tokens;
                    foreach my $token (@tokens) {
                        if ($token =~ /^[a-zA-Z]+$/) {
                            croak "Invalid day name '$token' in day-of-week field" unless $token =~ DOW_NAME_RE;
                            push @normalized_tokens, $dow_map{lc($token)};
                        } else {
                            push @normalized_tokens, $token;
                        }
                    }
                    $field = join ',', @normalized_tokens;
                    print STDERR "DEBUG: normalize_expression: DOW_NAME_RE substitution: '$original_field' -> '$field'\n" if $ENV{Cron_DEBUG};
                }
            }
            croak "Invalid pattern '$field' for dow" unless $field =~ DOW_PATTERN_RE;
            $field = uc($field);
        }

        $fields[$i] = $field;
    }

    my $normalized = join ' ', @fields;
    print STDERR "DEBUG: normalize_expression: after='$normalized'\n" if $ENV{Cron_DEBUG};
    return $normalized;
}

sub is_valid {
    my ($self) = @_;
    return $self->{is_valid};
}

sub error_message {
    my ($self) = @_;
    return $self->{error_message};
}

sub to_hash {
    my ($self) = @_;
    return [ map { $_->to_hash } @{$self->{patterns}} ];
}

sub to_string {
    my ($self) = @_;
    return join ' ', map { $_->to_string } @{$self->{patterns}};
}

sub quartz_dow {
    my ($iso_dow) = @_;
    return $iso_dow == 7 ? 1 : $iso_dow + 1;
}

sub is_match {
    my ($self, $tm) = @_;
    croak "Time::Moment object required" unless ref($tm) eq 'Time::Moment';

    print STDERR "DEBUG: is_match: input_epoch=" . $tm->epoch . ", utc_time=" . $tm->strftime('%Y-%m-%d %H:%M:%S %z') . ", input_offset=" . $tm->offset . "\n" if $ENV{Cron_DEBUG};
    my $tm_adjusted = $tm->with_offset_same_instant($self->{utc_offset});
    print STDERR "DEBUG: is_match: adjusted_time=" . $tm_adjusted->strftime('%Y-%m-%d %H:%M:%S %z') . ", adjusted_offset=" . $tm_adjusted->offset . ", utc_offset=$self->{utc_offset}\n" if $ENV{Cron_DEBUG};
    my @values = (
        $tm_adjusted->second,
        $tm_adjusted->minute,
        $tm_adjusted->hour,
        $tm_adjusted->day_of_month,
        $tm_adjusted->month,
        quartz_dow($tm_adjusted->day_of_week),
        $tm_adjusted->year
    );
    my @pattern_values = map { $_->to_string } @{$self->{patterns}};
    print STDERR "DEBUG: is_match: components=[second=$values[0], minute=$values[1], hour=$values[2], dom=$values[3], month=$values[4], dow=$values[5], year=$values[6]], expected=[second=$pattern_values[0], minute=$pattern_values[1], hour=$pattern_values[2], dom=$pattern_values[3], month=$pattern_values[4], dow=$pattern_values[5], year=$pattern_values[6]]\n" if $ENV{Cron_DEBUG};

    for my $i (0..6) {
        my $field_type = [qw(seconds minute hour dom month dow year)]->[$i];
        my $pattern_value = $self->{patterns}[$i] ? $self->{patterns}[$i]->to_string : 'undef';
        print STDERR "DEBUG: is_match: field=$i, field_type=$field_type, value=$values[$i], pattern=" . (ref($self->{patterns}[$i]) || 'undef') . ", pattern_value=$pattern_value, utc_offset=$self->{utc_offset}\n" if $ENV{Cron_DEBUG};
        my $match = $self->{patterns}[$i] && $self->{patterns}[$i]->is_match($values[$i], $tm_adjusted);
        print STDERR "DEBUG: is_match: Match " . ($match ? "succeeded" : "failed") . " for field=$i ($field_type, value=$values[$i], pattern_value=$pattern_value)\n" if $ENV{Cron_DEBUG};
        return 0 unless $match;
    }
    print STDERR "DEBUG: is_match: All fields matched, returning 1\n" if $ENV{Cron_DEBUG};
    return 1;
}

sub to_english {
    my ($self) = @_;
    return $self->{error_message} unless $self->is_valid;

    my @patterns = @{$self->{patterns}};  # RAW OBJECTS
    use Data::Dumper;
    print STDERR Dumper(\@patterns);
    return $self->_match_template(@patterns);
}

sub _match_template {
    my ($self, $sec_p, $min_p, $hour_p, $dom_p, $mon_p, $dow_p, $year_p) = @_;
    use Cron::Describe::Utils qw(fill_template format_list num_to_ordinal @day_names field_unit join_parts);

    # SAFE SINGLE CHECKS
    sub _is_single { my ($p, $val) = @_; $p->{pattern_type} eq 'single' && $p->{value} eq $val }

    # T1: Every minute (min=wildcard, hour=wildcard ONLY)
    if (_is_single($sec_p, '0') && $min_p->{pattern_type} eq 'wildcard' && $hour_p->{pattern_type} eq 'wildcard' &&
        $dom_p->{pattern_type} eq 'wildcard' && $mon_p->{pattern_type} eq 'wildcard' &&
        ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        return 'every minute';
    }

    # T2: Every [DAY] - FIXED: hour=single=0
    if (_is_single($sec_p, '0') && _is_single($min_p, '0') && _is_single($hour_p, '0') && $dom_p->{pattern_type} eq 'unspecified' &&
        $mon_p->{pattern_type} eq 'wildcard' && $dow_p->{pattern_type} eq 'single' && $year_p->{pattern_type} eq 'wildcard') {
        return "every " . $day_names[$dow_p->{value}] . " at midnight";
    }

    # T3: Every day at time - FIXED: hour=single=0
    if (_is_single($sec_p, '0') && _is_single($min_p, '0') && _is_single($hour_p, '0') && $dom_p->{pattern_type} eq 'wildcard' &&
        $mon_p->{pattern_type} eq 'wildcard' && ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return "every day at $time";
    }

    # T4: Every hour - FIXED: min=single=0
    if (_is_single($sec_p, '0') && _is_single($min_p, '0') && $hour_p->{pattern_type} eq 'wildcard' && $dom_p->{pattern_type} eq 'wildcard' &&
        $mon_p->{pattern_type} eq 'wildcard' && ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        return 'every hour';
    }

    # T5: Every 30 minutes - FIXED: min=single=30
    if (_is_single($sec_p, '0') && _is_single($min_p, '30') && $hour_p->{pattern_type} eq 'wildcard' && $dom_p->{pattern_type} eq 'wildcard' &&
        $mon_p->{pattern_type} eq 'wildcard' && ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        return 'every 30 minutes';
    }

    # T6: DOM at time
    if (($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $dom_p->{pattern_type} eq 'single' && $mon_p->{pattern_type} eq 'wildcard') {
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return sprintf("on the %s of the month at $time", num_to_ordinal($dom_p->{value}));
    }

    # T7: Every step
    if (_is_single($sec_p, '0') && $min_p->{pattern_type} eq 'step' && $hour_p->{pattern_type} eq 'wildcard' &&
        $dom_p->{pattern_type} eq 'wildcard' && $mon_p->{pattern_type} eq 'wildcard' &&
        ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        my $interval = $min_p->{step};
        return fill_template('every_step', interval => $interval, unit => field_unit('minute', $interval));
    }

    # T8: DOM list - FIXED: dom=list
    if (($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $dom_p->{pattern_type} eq 'list' && $mon_p->{pattern_type} eq 'wildcard') {
        my @values = map { $_->{value} } @{$dom_p->{patterns}};
        my $list = format_list('dom', @values);
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return fill_template('dom_list', list => $list) . ($time ? " at $time" : '');
    }

    # T9: DOM range - FIXED: dom=range
    if (($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $dom_p->{pattern_type} eq 'range' && $mon_p->{pattern_type} eq 'wildcard') {
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return fill_template('dom_range', start => num_to_ordinal($dom_p->{start_value}), end => num_to_ordinal($dom_p->{end_value})) . ($time ? " at $time" : '');
    }

    # T10: DOW list - FIXED: dow=list
    if (($dom_p->{pattern_type} eq 'wildcard' || $dom_p->{pattern_type} eq 'unspecified') && $dow_p->{pattern_type} eq 'list') {
        my @values = map { $_->{value} } @{$dow_p->{patterns}};
        my $list = join_parts(map { $day_names[int($_)] } @values);
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return fill_template('dow_list', list => $list) . ($time ? " at $time" : '');
    }

    # T11: DOW range - FIXED: dow=range + DOW offset
    if (($dom_p->{pattern_type} eq 'wildcard' || $dom_p->{pattern_type} eq 'unspecified') && $dow_p->{pattern_type} eq 'range') {
        my $start_day = $day_names[int($dow_p->{start_value})];
        my $end_day = $day_names[int($dow_p->{end_value})];
        my $time = $self->_time_phrase($min_p->{value}, $hour_p->{value});
        return "on $start_day through $end_day" . ($time ? " at $time" : '');
    }

    # T12: Step range - FULL STEP SUPPORT
    if (_is_single($sec_p, '0') && $min_p->{pattern_type} eq 'step' && _is_single($hour_p, '8') &&
        $dom_p->{pattern_type} eq 'wildcard' && $mon_p->{pattern_type} eq 'wildcard' &&
        ($dow_p->{pattern_type} eq 'wildcard' || $dow_p->{pattern_type} eq 'unspecified') && $year_p->{pattern_type} eq 'wildcard') {
        my $base_type = $min_p->{base}{pattern_type};
        my ($start, $end);
        if ($base_type eq 'single') {
            $start = $end = $min_p->{base}{value};
        } elsif ($base_type eq 'range') {
            $start = $min_p->{base}{start_value};
            $end = $min_p->{base}{end_value};
        } else {  # wildcard
            $start = $min_p->{min};
            $end = $min_p->{max};
        }
        my $interval = $min_p->{step};
        return fill_template('step_range', interval => $interval, unit => 'minutes', start => $start, end => $end) . " past 8 AM";
    }

    return '';
}

sub _time_phrase {
    my ($self, $min, $hour) = @_;
    use Cron::Describe::Utils qw(format_time);

    my $h = int($hour eq '*' ? 0 : $hour);
    my $m = int($min eq '*' ? 0 : $min);

    #return 'midnight' if $h == 0 && $m == 0;
    #return format_time(0, 0);
    return 'midnight'
}

1;
